# Threading & Concurrency

### Thread Unit Holds:
* Thread ID
* Program Counter (PC)
* Register Set
* Stack

With Other Threads belong to the same Process, it shares **code** & **data** sections, aswell as stuff like Open files, signals, etc...

![OS52](./static/OS_60.png)

**Important**: It only makes a real difference for Multi-core, as if Threads split up 1 core, then it's *NOT* a performance boost !!!

# Processes V. Threads

| Aspect                          | Process                                        | Thread                                      |
|---------------------------------|------------------------------------------------|---------------------------------------------|
| Weight                          | Heavyweight, resource-intensive                | Lightweight, uses fewer resources          |
| Memory Sharing                  | Sharing memory is complex, often requires additional management schemes | Threads in the same process can easily share memory; separate allocation is rare |
| Creation and Execution Overhead | Creating, executing, and switching processes is time-consuming | Creating, executing, and switching threads is faster |
| Coupling and Resource Sharing   | Loosely coupled, limited resource sharing      | Tightly coupled, extensive resource sharing possible |
| Communication                   | Complex, often requires system calls           | Simpler and more efficient, as threads can directly communicate through shared memory |
| Isolation                       | Processes are isolated, reducing the risk of one process affecting another | Threads share the same process space, so a fault in one thread can affect others |
| Resource Allocation             | Each process has its own memory and file resources | Threads share resources of their parent process, leading to efficient resource usage |
| Synchronization                 | Inter-process synchronization is more complex due to separate memory spaces | Easier within the same process due to shared memory, but requires careful handling to avoid issues like deadlocks |
| Scalability                     | Less scalable due to higher overheads in creating and managing processes | More scalable in multi-threaded applications, can efficiently use multi-core processors |
| Use Cases                       | Suitable for applications requiring isolation and security, like database management systems | Ideal for tasks requiring frequent communication or shared resources, like web servers |

* Most modern applications are typically multithreaded !
    - Single Process, Several Threads of Control

### Multithreaded Programming in Applications
- **Example: Word Processor**
  - Multiple tasks within a word processor can be handled by separate threads, such as:
    - Updating display
    - Fetching data
    - Performing spell checking
    - Answering network requests
- **Key Points**
  - Process creation is heavy-weight, while thread creation is light-weight.
  - Threads simplify code and increase efficiency.
  - Kernels are generally multithreaded, handling tasks like device management, memory management, and interrupt handling.

### Benefits of Multithreaded Programming
1. **Responsiveness**
   - Allows continued execution if part of the process is blocked.
   - Crucial for user interfaces.
   - Example: In a single-threaded application, a time-consuming operation initiated by a user action (like clicking a button) can make the application unresponsive.

2. **Resource Sharing**
   - Threads share resources of their parent process, easier than shared memory or message passing between processes.

3. **Economy**
   - Creating and switching threads has lower overhead than processes.
   - Example: In Solaris, creating a process is about 30 times slower than creating a thread; context switching is about 5 times slower.

4. **Scalability**
   - Multithreading can exploit multiprocessor architectures.
   - Threads can run in parallel on different processing cores.

### Multithreading and Computing Cores
- **Improved Efficiency and Concurrency**
  - Multithreaded programming allows more efficient use of multiple computing cores.
- **Challenges in Multicore/Multiprocessor Systems**
  - Dividing activities into separate, concurrent tasks.
  - Ensuring balance: tasks should perform equal work of equal value.
  - Managing data splitting and data dependency.
  - Testing and debugging in a concurrent environment.

# Concurrency vs. Parallelism

![OS52](./static/OS_61.png)