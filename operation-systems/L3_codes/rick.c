
//* Rick.c | Writes to Message Queue

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

struct my_msgbuf {
long mtype;
char mtext[200];
};

int main(void) {
    
    struct my_msgbuf buf;
    int msqid;
    key_t key;

    //* Generate a unique key for the message queue using 'rick.c' and a character 'B'.
    if ((key = ftok("rick.c", 'B')) == -1) {
        perror("ftok");
        exit(1);
    }

    /* 
    Function: msgget
    Purpose: To get the identifier for a System V message queue.
    Usage: int msgget(key_t key, int msgflg);

    Parameters:
    1. key: Unique key generated by ftok or any other means, used to identify the message queue.
        - In this case, 'key' is obtained from ftok("rick.c", 'B').
    
    2. msgflg: Message operation flags. Determines the action to be taken.
        - 0644: These are the permissions for the message queue (similar to file permissions).
                In octal, '6' (read and write for owner), '4' (read-only for group), 
                and '4' (read-only for others).
        - IPC_CREAT: A flag that tells the system to create a new message queue if one 
                     with the given key doesn't already exist.
        - The '|' operator is a bitwise OR. It combines 0644 and IPC_CREAT flags.
           This means the message queue will have 0644 permissions, and it will be 
           created if it does not exist.

    Return Value:
    - Returns the message queue identifier (msqid) on success.
    - Returns -1 on failure, and errno is set to indicate the error.

    Error Handling:
    - If msqid is -1, perror("msgget") is used to print the error related to msgget failure.
    */

    if ((msqid = msgget(key, 0644 | IPC_CREAT)) == -1) {
        perror("msgget");
        exit(1);
    }

    printf("Enter lines of text, ^D to quit:\n");
    buf.mtype = 1; /* we don't really care in this case */

    //* fgets gets a new line from stdin, and puts it into the buf.mtext buffer, so the while loop check if it isn't null, to send the message

    while (fgets(buf.mtext, sizeof buf.mtext, stdin) != NULL){
        int len = strlen(buf.mtext);

        /* ditch newline at end, if it exists */
        if (buf.mtext[len - 1] == '\n')
        buf.mtext[len - 1] = '\0'; //* Append Null Terminator instead
        
        //* Send Pointer of Buffer, to specific message queue id, whilst including len, with an extra char (null terminator)
        if (msgsnd(msqid, &buf, len + 1, 0) == -1) 
        perror("msgsnd");
    }

    if (msgctl(msqid, IPC_RMID, NULL) == -1) {
    perror("msgctl");
    exit(1);
    }

return 0;
}